// 潮流计算模块 - power_flow.rs
fn newton_pf(baseMVA, bus, gen, branch, max_iter, tol) {
    /*
    牛顿-拉夫逊法潮流计算
    参数:
      baseMVA: 基准功率
      bus: 母线数据矩阵
      gen: 发电机数据矩阵
      branch: 支路数据矩阵
      max_iter: 最大迭代次数
      tol: 收敛容差
    返回:
      [收敛标志, 迭代次数, 电压幅值, 电压相角, 系统损耗]
    */

    // 常量定义（使用0基索引）
    BUS_I = 0;      // 母线编号
    BUS_TYPE = 1;   // 母线类型
    PD = 2;         // 有功负荷
    QD = 3;         // 无功负荷
    GS = 4;         // 电导
    BS = 5;         // 电纳
    VM = 7;         // 电压幅值
    VA = 8;         // 电压相角

    GEN_BUS = 0;    // 发电机所连母线
    PG = 1;         // 发电机有功
    QG = 2;         // 发电机无功

    F_BUS = 0;      // 支路首端母线
    T_BUS = 1;      // 支路末端母线
    BR_R = 2;       // 支路电阻
    BR_X = 3;       // 支路电抗
    BR_B = 4;       // 支路电纳

    // 母线类型常量
    PQ = 1;
    PV = 2;
    REF = 3;

    // 获取系统规模
    nb = size(bus, 0);      // 母线数量
    ng = size(gen, 0);      // 发电机数量
    nl = size(branch, 0);   // 支路数量

    // 1. 形成节点导纳矩阵Ybus
    Ybus = zeros(nb, nb);

    for k in 0..nl {
        // 获取支路参数
        f = get(branch, k, F_BUS) - 1;  // 转换为0基索引
        t = get(branch, k, T_BUS) - 1;  // 转换为0基索引
        r = get(branch, k, BR_R);
        x = get(branch, k, BR_X);
        b = get(branch, k, BR_B);

        // 计算支路导纳
        if r == 0 && x == 0 {
            y = 0;
        } else {
            z = r + c(0, 1) * x;
            y = 1 / z;
        }

        // 更新节点导纳矩阵
        // Yff
        Yff = get(Ybus, f, f) + y + c(0, 0.5) * b;
        assign(Ybus, [[Yff]], [f, f+1], [f, f+1]);

        // Yft
        Yft = get(Ybus, f, t) - y;
        assign(Ybus, [[Yft]], [f, f+1], [t, t+1]);

        // Ytf
        Ytf = get(Ybus, t, f) - y;
        assign(Ybus, [[Ytf]], [t, t+1], [f, f+1]);

        // Ytt
        Ytt = get(Ybus, t, t) + y + c(0, 0.5) * b;
        assign(Ybus, [[Ytt]], [t, t+1], [t, t+1]);
    }

    // 添加母线并联导纳
    for i in 0..nb {
        gs = get(bus, i, GS);
        bs = get(bus, i, BS);
        Yii = get(Ybus, i, i) + c(gs, bs);
        assign(Ybus, [[Yii]], [i, i+1], [i, i+1]);
    }

    // 2. 初始化电压
    Vm = slice(bus, [0], [VM-1, VM]);  // 电压幅值（二维张量）
    Va = slice(bus, [0], [VA-1]);      // 电压相角（一维张量）

    // 3. 确定节点类型和索引
    bus_type = slice(bus, [0], [BUS_TYPE-1, BUS_TYPE]);

    // 统计各类节点数量
    pq_count = 0;
    pv_count = 0;

    for i in 0..nb {
        bus_type_i = get(bus_type, i, 0);
        if bus_type_i == PQ {
            pq_count = pq_count + 1;
        } else if bus_type_i == PV {
            pv_count = pv_count + 1;
        }
    }

    // 创建PQ和PV节点索引
    pq_idx = zeros(pq_count);
    pv_idx = zeros(pv_count);

    pq_count_temp = 0;
    pv_count_temp = 0;

    for i in 0..nb {
        bus_type_i = get(bus_type, i, 0);
        if bus_type_i == PQ {
            assign(pq_idx, [i], [pq_count_temp, pq_count_temp+1], [0]);
            pq_count_temp = pq_count_temp + 1;
        } else if bus_type_i == PV {
            assign(pv_idx, [i], [pv_count_temp, pv_count_temp+1], [0]);
            pv_count_temp = pv_count_temp + 1;
        }
    }

    // 合并PV和PQ节点索引
    n = pv_count + pq_count;  // 待求变量总数
    pvpq_idx = zeros(n);

    for i in 0..pv_count {
        val = get(pv_idx, i);
        assign(pvpq_idx, [val], [i, i+1], [0]);
    }

    for i in 0..pq_count {
        val = get(pq_idx, i);
        assign(pvpq_idx, [pv_count + i, pv_count + i+1], [0], [val]);
    }

    // 4. 计算节点注入功率
    // 4.1 计算负荷
    Pd = slice(bus, [0], [PD-1]);  // 有功负荷
    Qd = slice(bus, [0], [QD-1]);  // 无功负荷

    // 4.2 计算发电
    Pg = zeros(nb);
    Qg = zeros(nb);

    for g in 0..ng {
        bus_i = get(gen, g, GEN_BUS) - 1;  // 转换为0基索引
        pg_val = get(gen, g, PG) / baseMVA;
        qg_val = get(gen, g, QG) / baseMVA;

        // 累加发电功率
        current_pg = get(Pg, bus_i);
        assign(Pg, [current_pg + pg_val], [bus_i, bus_i+1], [0]);

        current_qg = get(Qg, bus_i);
        assign(Qg, [current_qg + qg_val], [bus_i, bus_i+1], [0]);
    }

    // 4.3 计算净注入功率
    P = Pg - Pd;
    Q = Qg - Qd;

    // 5. 牛顿-拉夫逊迭代
    converged = 0;  // 0表示未收敛，1表示收敛
    iter = 0;

    while iter < max_iter {
        // 5.1 计算节点注入功率
        // 创建复电压向量
        V = zeros(1, nb);
        for i in 0..nb {
            V_i = c(get(Vm, i, 0), 0) * exp(c(0, 1) * get(Va, i));
            assign(V, [[V_i]], [0, 1], [i, i+1]);
        }

        // 计算节点电流
        I = Ybus * transpose(V);
        S = V .* conj(I);

        // 计算功率不平衡量
        P_calc = real(S);
        Q_calc = imag(S);

        dP = P - P_calc;
        dQ = Q - Q_calc;

        // 5.2 构建雅可比矩阵
        // 初始化雅可比矩阵
        J = zeros(n, n);

        // 5.2.1 计算雅可比矩阵元素
        for i in 0..n {
            bus_i = get(pvpq_idx, i);
            Vi = get(V, 0, bus_i);

            for j in 0..n {
                bus_j = get(pvpq_idx, j);
                Yij = get(Ybus, bus_i, bus_j);
                Vj = get(V, 0, bus_j);

                // 计算相角差
                theta_ij = arg(Vi) - arg(Vj) - arg(Yij);

                if i < pv_count {
                    // PV节点行（对应有功方程）
                    if j < pv_count {
                        // PV节点列（对应相角变量）
                        if i == j {
                            // 对角线元素 Hii
                            sum_val = 0;
                            for k in 0..nb {
                                if k != bus_i {
                                    Yik = get(Ybus, bus_i, k);
                                    Vk = get(V, 0, k);
                                    theta_ik = arg(Vi) - arg(Vk) - arg(Yik);
                                    sum_val = sum_val + abs(Vi) * abs(Vk) * abs(Yik) * sin(theta_ik);
                                }
                            }
                            Hii = -abs(Vi)^2 * imag(Yij) - sum_val;
                            assign(J, [[Hii]], [i, i+1], [j, j+1]);
                        } else {
                            // 非对角线元素 Hij
                            Hij = abs(Vi) * abs(Vj) * abs(Yij) * sin(theta_ij);
                            assign(J, [[Hij]], [i, i+1], [j, j+1]);
                        }
                    } else {
                        // PQ节点列（对应电压幅值变量）
                        if bus_i == bus_j {
                            // 对角线元素 Nii
                            sum_val = 0;
                            for k in 0..nb {
                                if k != bus_i {
                                    Yik = get(Ybus, bus_i, k);
                                    Vk = get(V, 0, k);
                                    theta_ik = arg(Vi) - arg(Vk) - arg(Yik);
                                    sum_val = sum_val + abs(Vk) * abs(Yik) * cos(theta_ik);
                                }
                            }
                            Nii = abs(Vi) * real(Yij) + sum_val;
                            assign(J, [[Nii]], [i, i+1], [j, j+1]);
                        } else {
                            // 非对角线元素 Nij
                            Nij = -abs(Vi) * abs(Yij) * cos(theta_ij);
                            assign(J, [[Nij]], [i, i+1], [j, j+1]);
                        }
                    }
                } else {
                    // PQ节点行（对应无功方程）
                    if j < pv_count {
                        // PV节点列（对应相角变量）
                        if bus_i == bus_j {
                            // 对角线元素 Jii
                            sum_val = 0;
                            for k in 0..nb {
                                if k != bus_i {
                                    Yik = get(Ybus, bus_i, k);
                                    Vk = get(V, 0, k);
                                    theta_ik = arg(Vi) - arg(Vk) - arg(Yik);
                                    sum_val = sum_val + abs(Vk) * abs(Yik) * sin(theta_ik);
                                }
                            }
                            Jii = abs(Vi) * real(Yij) - sum_val;
                            assign(J, [[Jii]], [i, i+1], [j, j+1]);
                        } else {
                            // 非对角线元素 Jij
                            Jij = abs(Vi) * abs(Yij) * sin(theta_ij);
                            assign(J, [[Jij]], [i, i+1], [j, j+1]);
                        }
                    } else {
                        // PQ节点列（对应电压幅值变量）
                        if i == j {
                            // 对角线元素 Lii
                            sum_val = 0;
                            for k in 0..nb {
                                if k != bus_i {
                                    Yik = get(Ybus, bus_i, k);
                                    Vk = get(V, 0, k);
                                    theta_ik = arg(Vi) - arg(Vk) - arg(Yik);
                                    sum_val = sum_val + abs(Vk) * abs(Yik) * cos(theta_ik);
                                }
                            }
                            Lii = abs(Vi) * imag(Yij) + sum_val;
                            assign(J, [[Lii]], [i, i+1], [j, j+1]);
                        } else {
                            // 非对角线元素 Lij
                            Lij = -abs(Vi) * abs(Yij) * cos(theta_ij);
                            assign(J, [[Lij]], [i, i+1], [j, j+1]);
                        }
                    }
                }
            }
        }

        // 5.3 构建不平衡量向量
        F = zeros(n, 1);

        // PV节点的不平衡量（有功）
        for i in 0..pv_count {
            bus_i = get(pv_idx, i);
            val = get(dP, bus_i);
            assign(F, [[val]], [i, i+1], [0, 1]);
        }

        // PQ节点的不平衡量（有功和无功）
        for i in 0..pq_count {
            bus_i = get(pq_idx, i);
            // 有功不平衡量
            val_p = get(dP, bus_i);
            assign(F, [[val_p]], [pv_count + i, pv_count + i+1], [0, 1]);

            // 无功不平衡量
            val_q = get(dQ, bus_i);
            assign(F, [[val_q]], [pv_count + i, pv_count + i+1], [0, 1]);
        }

        // 5.4 求解修正方程
        dx = linsolve(J, F);

        // 5.5 更新电压
        // 更新相角
        for i in 0..n {
            bus_i = get(pvpq_idx, i);
            dtheta = get(dx, i, 0);
            current_angle = get(Va, bus_i);
            assign(Va, [current_angle + dtheta], [bus_i, bus_i+1], [0]);
        }

        // 更新电压幅值（仅PQ节点）
        for i in 0..pq_count {
            bus_i = get(pq_idx, i);
            dV = get(dx, pv_count + i, 0);
            current_voltage = get(Vm, bus_i, 0);
            assign(Vm, [[current_voltage + dV]], [bus_i, bus_i+1], [0, 1]);
        }

        // 5.6 检查收敛条件
        max_mismatch = 0;

        // 检查PV节点的有功不平衡量
        for i in 0..pv_count {
            bus_i = get(pv_idx, i);
            mismatch = abs(get(dP, bus_i));
            if mismatch > max_mismatch {
                max_mismatch = mismatch;
            }
        }

        // 检查PQ节点的有功和无功不平衡量
        for i in 0..pq_count {
            bus_i = get(pq_idx, i);
            mismatch_p = abs(get(dP, bus_i));
            mismatch_q = abs(get(dQ, bus_i));

            if mismatch_p > max_mismatch {
                max_mismatch = mismatch_p;
            }

            if mismatch_q > max_mismatch {
                max_mismatch = mismatch_q;
            }
        }

        // 判断是否收敛
        if max_mismatch < tol {
            converged = 1;
            break;
        }

        iter = iter + 1;
    }

    // 6. 计算系统损耗
    // 重新计算复电压
    V = zeros(1, nb);
    for i in 0..nb {
        V_i = c(get(Vm, i, 0), 0) * exp(c(0, 1) * get(Va, i));
        assign(V, [[V_i]], [0, 1], [i, i+1]);
    }

    // 计算节点注入功率
    I = Ybus * transpose(V);
    S = V .* conj(I);

    // 计算系统总损耗
    P_loss = sum_all(real(S));
    Q_loss = sum_all(imag(S));

    // 7. 返回结果
    // 创建结果矩阵
    result_rows = 3 + nb + nb;
    result = zeros(result_rows, 1);

    // 收敛标志
    assign(result, [[converged]], [0, 1], [0, 1]);

    // 迭代次数
    assign(result, [[iter]], [1, 2], [0, 1]);

    // 电压幅值
    for i in 0..nb {
        vm_val = get(Vm, i, 0);
        assign(result, [[vm_val]], [2 + i, 2 + i+1], [0, 1]);
    }

    // 电压相角（弧度）
    for i in 0..nb {
        va_val = get(Va, i);
        assign(result, [[va_val]], [2 + nb + i, 2 + nb + i+1], [0, 1]);
    }

    // 系统有功损耗
    assign(result, [[P_loss]], [2 + nb + nb, 2 + nb + nb+1], [0, 1]);

    return result;
}

// 潮流计算示例函数
fn run_power_flow_example() {
    // 系统基准功率
    baseMVA = 100;

    // 最大迭代次数和收敛容差
    max_iter = 10;
    tol = 1e-6;

    // 母线数据（IEEE 4节点系统示例）
    bus = [
        [1, 3, 0, 0, 0, 0, 1, 1.06, 0, 0, 1, 1.06, 0.94],
        [2, 1, 20, 10, 0, 0, 1, 1.0, 0, 0, 1, 1.06, 0.94],
        [3, 2, 45, 15, 0, 0, 1, 1.0, 0, 0, 1, 1.06, 0.94],
        [4, 1, 40, 5, 0, 0, 1, 1.0, 0, 0, 1, 1.06, 0.94]
    ];

    // 发电机数据
    gen = [
        [1, 0, 0, 0, 0, 1.06, 100, 1, 100, 0],
        [3, 50, 0, 0, 0, 1.0, 100, 1, 100, 0]
    ];

    // 支路数据
    branch = [
        [1, 2, 0.01, 0.03, 0, 0, 0, 0, 0, 0, 1, -360, 360],
        [1, 3, 0.02, 0.05, 0, 0, 0, 0, 0, 0, 1, -360, 360],
        [2, 3, 0.03, 0.08, 0, 0, 0, 0, 0, 0, 1, -360, 360],
        [2, 4, 0.015, 0.04, 0, 0, 0, 0, 0, 0, 1, -360, 360],
        [3, 4, 0.025, 0.06, 0, 0, 0, 0, 0, 0, 1, -360, 360]
    ];

    // 运行潮流计算
    result = newton_pf(baseMVA, bus, gen, branch, max_iter, tol);

    // 解析结果
    converged = get(result, 0, 0);
    iterations = get(result, 1, 0);
    nb = size(bus, 0);

    // 输出结果
    print_str = "潮流计算结果:";
    print(print_str);

    if converged == 1 {
        print_str = "收敛状态: 已收敛";
        print(print_str);
    } else {
        print_str = "收敛状态: 未收敛";
        print(print_str);
    }

    print_str = "迭代次数: " + iterations;
    print(print_str);

    // 电压幅值损耗
    loss = get(result, 2 + nb + nb, 0);
    print_str = "系统有功损耗: " + loss + " MW";
    print(print_str);


    // 母线电压结果
    print_str = "母线电压结果:";
    print(print_str);
    print_str = "母线\t电压幅值(pu)\t相角(度)";
    print(print_str);

    for i in 0..nb {
        bus_num = i + 1;  // 转换为1基编号
        vm = get(result, 2 + i, 0);
        va_rad = get(result, 2 + nb + i, 0);
        va_deg = rad2deg(va_rad);


        // 四舍五入到4位小数
        vm_int = floor(vm * 10000);
        vm_str = vm_int / 10000;

        // 四舍五入到2位小数
        va_int = floor(va_deg * 100);
        va_str = va_int / 100;

        print_str = bus_num + "\t" + vm_str + "\t\t" + va_str;
        print(print_str);
    }

    return result;
}

println(run_power_flow_example())